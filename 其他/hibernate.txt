hibernate 通过配置文件的元数据 可以不用在数据库建表，但是这样设计的初衷是面向对象，希望针对实体来建立数据库，而不是希望人们省略这个步骤

hibernate其实是通过反射创建对象的 加载全类名,然后调用newInstance()方法,这个方法就是空参构造，所以才说是调用空参构造方法

实体类的get/set方法就是属性 ，成员变量不是属性

Java共有六个包装类，分别是Boolean、Character、Integer、Long、Float和Double，从字面上就能够看出分别对应于 boolean、char、int、long、float和double。而String和Date本身就是类。所以也就不存在什么包装类的概念了。
包装类把基本数据类型变成对象类型，使用包装类型没有任何的不便
使用包装类型可以有更多值 
对于任何的包装类都存在一个名为toString()的方法能够将其转换成对应的String类
像ArrayList这样的集合是不能储存基本类型的只能储存对象 为了方便这些集合的使用所以才有了把基本类型包装成对象类型，使用包装类就可以放进去

没有主键的表不能映射到hibernate

代理主键 -- 和这个实体没什么关系 cid uid 
自然主键 -- 本身就是这个实体的一个属性，不过不唯一  身份证号

开启维护：
	一对多的时候：假如来个两方都维护，那么就是两方都修改这个外键
	多对多的时候：假如两方都维护，那么两方都要向中间表插入数据，就造成冲突了（主键重复）。假如都要代码中两方都表达关系，就应该放弃维护。实际开发中应该有一方放弃维护，权力大、重量比较大的一方放弃维护，就是有一方的配置文件写true

new xxx(): new xxx代表堆空间里创建一个xxx对象，（）则表示调用xxx的构造函数，对生成的对象进行初始化
xxx yyy = new xxx() ：yyy并不是对象，而是一个对象的引用，new xxx才是创建了一个对象， “=”代表指向  yyy不过是指向它。yyy也叫引用变量，或者说对象句柄。

super代表父类实例本身
super.xxx ：引用父类的成员变量
super.yyy()：引用父类的成员函数
super()：引用父类的构造函数

this代表的是本类的实例本身
this.xxx：引用本类的成员变量
this.yyy()：引用本类的成员变量
this():引用本类的构造函数
this.class是获得这个类相对于Class类的对象

子类实例化的过程会先去执行父类的构造函数，这个大家肯定都是知道，但我过去错误的以为，执行了父类的构造函数意味着新建了父类的对象.......，所以我才会觉得父类中的this指的应该是父类的对象引用。但是，其实我上面写的这些类的过程中，仅仅的是创建了son1,son2,son3这个子类对象，虽然都走了父类的构造函数，但是并不创建父类对象，所以父类中的this便指的是他子类的具体this。
我做的测试是，实例化子类，看父类中this关键字是谁。若你们正常去是实例化父类，那么你执行父类中相应的方法，那么方法中的this值得就是父类对象本身的引用
总结就是：要看实例化的是谁

hibernate三种查询方式： hql 
			criteria 
			sql
hql criteria 是基于对象的查询语句，所以不用封装对象
sql ：原生的对象，所以需要封装
不过都是 创建查询对象（Query Criteria SQLquery）--- 操作 --- 执行

List 可重复、有序
Set 不可重复、无序
Map 键值对，不允许有重复键，允许有重复值，无序

懒加载：
	true：使用到才发送sql
	extra（及其懒惰的）：使用到那一部分，就只查询就只查询具体的那一部分

抓取策略：查询到某个对象时，如何抓取其关联对象

多表联合查询
	内连接 查询结果各自封装
	迫切内连接 查询结果一起封装
	左外连接
	右外连接
	迫切左外连接
	

为何设置fetch时，join就失效 
	因为你如果使用fetch，那么不是一起封装了嘛，查询的时候已经一起查询了，








