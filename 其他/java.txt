new 代表调用构造函数实例化

一个类的静态代码块在该类被调用或者实例化的时候被执行

为什么用接口来接收对象，接口的引用指向它的实现类对象，就好比父类的引用指向它的实例化对象，-----这是多态的知识点

抽象类和接口的区别

多态的总结：
	一、使用父类类型的引用指向子类的对象；
	二、该引用只能调用父类中定义的方法和变量；
	三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）
	四、变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。

	List list = new ArrayList（） 只是更加的灵活

String a = "hello";
a.equals(new String("hello"));

super代表父类实例本身
super.xxx ：引用父类的成员变量
super.yyy()：引用父类的成员变量
super()：引用父类的构造函数

this代表的是本类的实例本身
this.xxx：引用本类的成员变量
this.yyy()：引用本类的成员变量
this():引用本类的构造函数
this.class是获得这个类相对于Class类的对象

子类实例化的过程会先去执行父类的构造函数，这个大家肯定都是知道，但我过去错误的以为，执行了父类的构造函数意味着新建了父类的对象.......，所以我才会觉得父类中的this指的应该是父类的对象引用。但是，其实我上面写的这些类的过程中，仅仅的是创建了son1,son2,son3这个子类对象，虽然都走了父类的构造函数，但是并不创建父类对象，所以父类中的this便指的是他子类的具体this。
我做的测试是，实例化子类，看父类中this关键字是谁。若你们正常去是实例化父类，那么你执行父类中相应的方法，那么方法中的this值得就是父类对象本身的引用
总结就是：要看实例化的是谁

cookie只能存字符串

Map是put放入
List是add放入

Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。

java使用unicode码,每个字符都占用2个字节